{
    "D1"    : "Main parametres are `r`, `c` and `hash_len`. `r` determins the rate at which bits are taken from input and processed (xorred with `r` bits from internal state). `c` determins how many bits of internal state won't be xored with input. This also determins the security, as they pretty much can't be 'directly' influced by input. Higher `c` = higher security. `hash_len` determins how many bits are taken from produced hash (n bits from multiples of 1600bits).",
    "m0"    : "0x69cb",
    "c0"    : 448,
    "hash0" : "0x94bd25c4cf6ca889126df37ddd9c36e6a9b28a4fe15cc3da6debcdd7",

    "D2"     : "The first message is 400B long (double the size of `r`). We know that input is procesed in `r` sized chunks, so it will take two 'rounds' to get the output hash. This means that if we take the internal state before the last round (after xor but before applying the function), we can use it as the first 200B of second the message (it will be xored with zeros), immediately creating the 'last' state of first message and the same hash at the end -> hash size does not matter",
    "m1"     : "0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "m2"     : "0xe7dde140798f25f18a47c033f9ccd584eea95aa61e2698d54d49806f304715bd57d05362054e288bd46f8e7f2da497ffc44746a4a0e5fe90762e19d60cda5b8c9c05191bf7a630ad64fc8fd0b75a933035d617233fa95aeb0321710d26e6a6a95f55cfdb167ca58126c84703cd31b8439f56a5111a2ff20161aed9215a63e505f270c98cf2febe641166c47b95703661cb0ed04f555a7cb8c832cf1c8ae83e8c14263aae22790c94e409c5a224f94118c26504e72635f5163ba1307fe944f67549a2ec5c7bfff1ea",
    "c12"    : 0,
    "hash12" : "0x3c9f5c6b4a247d36f482cd3967d232807fb2e040237c1005412804554f888e85b5ad7776f153146f9c7fefb78a4cd34cf83e504d0ab463e4cc1e9613038a34e52fe0823b7685444792a2ab6d15335ee26ddfaf91c224cd8801233f535860167afffdf3bffe2b3eaf03f087d4ad72c9f03c8c5ff063e5245d270577d90f484e8089a6cb0e0d61e4d2d7f14c0d90c38f6b2fd1d73e35a95570a0fc10398725e19d0643c76e00c5413d17ab82caa5bb9e9042ba6ac757604396cadcd686ff106e1af9d31a1919a72830",

    "D3"     : "I used multithreaded brute-force. Made an array of random messages (each message of len `r` bits), which was then given to workers (12 threads). Each returned a list containing messages and their state from absorbtion.  Starting with a message (<200B) I keep generating hashes (next message) and storing the internal state of absorbtion. All I need to do is check, if state with this `c` (last 40 bits) was already generated by some other message. If so, I can 'add' some suffix to the current message, xoring it with the state, getting the next xor. Xoring this xor value with our second message state, we get suffix for the second message. msg1+suffix1 and msg2+suffix2 will generate same hash",
    "m3"     : "0x832efc9c4e178534ee9d40bd3c8c4cd709e97551b5ec0287c8267c101298e32f95ba4042b0314b4c38d6c13dfb2865df5f2da731ee5e7463476e4347ffad8740a47b43dc320c18d88d7d77bd02774c7b53bd3721f8cd74fc1b1ebc5658f488149b870a7b211412ce0d51c225ab3417249fc84f5ecd7be8a88971ac7d04d29e4c768e2738d291aa0440baba47b9faa32b17216fc1be0a706255c5eb407174f32de13f6c8512d87ec0525cb49781a41fce76a2233bcf16b94aee320ac51ad06b486c94e6003b9a66db8716931cce4d50dbb91b0bc33ffc0ca5cf475baf0ed9c8a8f3a5fe6f18d326a4d5b856d57417feacbc005b7c88988ebbacb3977ecfda87c2237915b9ba45ddc36746255d9dd543883e60dddcf81f844c86a5afcd33c1f2a21f9de65e789e84851946581a4c887c26e10b8ee0258257696932163282960fca50f3dfb6a5ef78a4e85bbe83b60fec5feda6f65cefb684464c9aa45e36bbd7fbe1c403ae768ca343d74ccea8ab0487f640b6b59b9693cd55a85de7eec81280917d966562000000000000",
    "m4"     : "0x7084ab35216254284a4ced1ac077a99bc4cd37147d22e550091be122de54d9d8ff0264c5ee062c8606d05fb19caf7ebd13eb5125fb639be8d12924fc5ae083123d3d5fbd67e21e9dc717fe34c525dc7213ebe2f1f415f720a6d0c4f58eb14e415ede6a0fe9ac7861f8c6699b8aeb59d386f83969f477adcd80d6dc71923a26921d06fd3e9b070663d73c32b83369b30ba208f46869d2370ae0e0822bdc6e4a2a1351c5e24e82692e2186b006273f303e7fce5bcc18ee17accf94111d8bd7a254398e3700000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000",
    "c34"    : 48,
    "hash34" : "0x4edb3e00ce963267191c4e9bc72c79050a02a6bdc7481259c273495ca734b4e3bd2bf866412517b17978acd830581d1b168a3e92b07030dea2fd6746393e57fa93530213dba85d762e865b851564488f047c6174f5f44977d6a5538495daa5982aa68d701ce786874151b3ef043ec14c5606d83a20a58bfc3e67f88dfb3ecfaa2ab9eb9d546324d2116ad20ae9033f18fa41e70a3b32d46c9d971be7ec598201fcd2abb1a8b6990704898af63e7cf30a2dfa251092db5d73b2c21b1fbc1579376aad28265a4ade78",

    "max"    : 857,
    "min"    : 735,
    "avg"    : 799.68
}